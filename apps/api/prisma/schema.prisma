generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  PLAYER
  VENUE_OWNER
  REFEREE
  ADMIN
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum HoldStatus {
  ACTIVE
  RELEASED
  SETTLED
  CANCELLED
}

enum LedgerEntryType {
  CREDIT
  DEBIT
}

model User {
  id             String          @id @default(uuid())
  email          String          @unique
  passwordHash   String
  fullName       String
  avatarUrl      String?
  bio            String?
  preferredPositions String[] @default([])
  roleAssignments RoleAssignment[]
  refreshTokens  RefreshToken[]
  teamsOwned     Team[]          @relation("TeamOwner")
  teamMemberships TeamMember[]
  teamInvitations TeamInvitation[] @relation("InvitedUser")
  teamApplications TeamApplication[]
  venues         Venue[]
  bookings       Booking[]       @relation("BookingUser")
  ownedBookings  Booking[]       @relation("BookingOwner")
  wallet         Wallet?
  posts          Post[]
  stories        Story[]
  venueOwnerProfile VenueOwnerProfile?
  refereeVerification RefereeVerification?
  refereeAssignments MatchRefereeAssignment[]
  createdAt      DateTime        @default(now())
}

model Post {
  id        String   @id @default(uuid())
  userId    String
  content   String
  imageUrl  String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Story {
  id            String   @id @default(uuid())
  userId        String
  mediaUrl      String
  caption       String?
  isHighlighted Boolean  @default(false)
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RoleAssignment {
  id        String   @id @default(uuid())
  userId    String
  role      UserRole
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Team {
  id            String            @id @default(uuid())
  name          String
  ownerId       String
  description   String?
  shieldUrl     String?
  footballType  Int               @default(11)
  formation     String            @default("4-4-2")
  maxPlayers    Int
  isRecruiting  Boolean           @default(true)
  matchesPlayed Int               @default(0)
  wins          Int               @default(0)
  draws         Int               @default(0)
  losses        Int               @default(0)
  goalsFor      Int               @default(0)
  goalsAgainst  Int               @default(0)
  owner         User              @relation("TeamOwner", fields: [ownerId], references: [id])
  members       TeamMember[]
  invitations   TeamInvitation[]
  applications  TeamApplication[]
  homeMatches   Match[]           @relation("HomeTeam")
  awayMatches   Match[]           @relation("AwayTeam")
  queueEntries  MatchQueue[]
  createdAt     DateTime          @default(now())
}

model TeamMember {
  id       String   @id @default(uuid())
  teamId   String
  userId   String
  status   String
  role     String   @default("MEMBER")
  matchesPlayed Int  @default(0)
  goals         Int  @default(0)
  assists       Int  @default(0)
  yellowCards   Int  @default(0)
  redCards      Int  @default(0)
  cleanSheets   Int  @default(0)
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
}

model TeamInvitation {
  id           String   @id @default(uuid())
  teamId        String
  invitedUserId String
  status       String
  createdAt    DateTime @default(now())
  team         Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedUser  User     @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: Cascade)

  @@unique([teamId, invitedUserId])
}


model TeamApplication {
  id        String   @id @default(uuid())
  teamId     String
  userId     String
  message    String?
  status     String   @default("PENDING")
  createdAt  DateTime @default(now())
  reviewedAt DateTime?
  team       Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId, status])
}

enum MatchMode {
  CASUAL
  COMPETITIVE
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  FINISHED
  CANCELED
}

enum MatchQueueStatus {
  SEARCHING
  MATCHED
  CANCELED
}

model Match {
  id          String      @id @default(uuid())
  mode        MatchMode
  status      MatchStatus @default(SCHEDULED)
  homeTeamId  String
  awayTeamId  String
  createdAt   DateTime    @default(now())
  matchedAt   DateTime?
  homeTeam    Team        @relation("HomeTeam", fields: [homeTeamId], references: [id], onDelete: Cascade)
  awayTeam    Team        @relation("AwayTeam", fields: [awayTeamId], references: [id], onDelete: Cascade)
  queueEntries MatchQueue[]
  refereeAssignments MatchRefereeAssignment[]

  @@index([mode, status, createdAt])
}

model MatchRefereeAssignment {
  id         String   @id @default(uuid())
  matchId    String
  refereeId  String
  venueName  String?
  scheduledAt DateTime @default(now())
  status     String   @default("PENDING")
  createdAt  DateTime @default(now())
  match      Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  referee    User     @relation(fields: [refereeId], references: [id], onDelete: Cascade)

  @@index([refereeId, status])
}

model VenueOwnerProfile {
  id           String   @id @default(uuid())
  userId       String   @unique
  venueName    String
  venuePhotoUrl String?
  bio          String?
  address      String
  contactPhone String
  openingHours String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  owner        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fields       VenueField[]
}

model VenueField {
  id          String   @id @default(uuid())
  profileId   String
  name        String
  createdAt   DateTime @default(now())
  profile     VenueOwnerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  rates       VenueFieldRate[]
}

model VenueFieldRate {
  id          String   @id @default(uuid())
  fieldId     String
  dayOfWeek   Int
  startHour   Int
  endHour     Int
  price       Decimal  @db.Decimal(10,2)
  createdAt   DateTime @default(now())
  field       VenueField @relation(fields: [fieldId], references: [id], onDelete: Cascade)
}

model RefereeVerification {
  id              String   @id @default(uuid())
  userId          String   @unique
  documentUrl     String
  verificationStatus String @default("PENDING")
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  referee         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MatchQueue {
  id         String           @id @default(uuid())
  teamId     String
  mode       MatchMode
  status     MatchQueueStatus @default(SEARCHING)
  createdAt  DateTime         @default(now())
  matchedAt  DateTime?
  matchId    String?
  team       Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)
  match      Match?           @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([mode, status, createdAt])
  @@unique([teamId, mode, status])
}

model Venue {
  id          String   @id @default(uuid())
  ownerId     String
  name        String
  location    String
  pricePerHour Decimal @db.Decimal(10,2)
  owner       User     @relation(fields: [ownerId], references: [id])
  bookings    Booking[]
  createdAt   DateTime @default(now())
}

model Booking {
  id           String       @id @default(uuid())
  venueId       String
  userId        String
  ownerId       String
  startsAt      DateTime
  endsAt        DateTime
  totalAmount   Decimal      @db.Decimal(10,2)
  commissionAmount Decimal    @db.Decimal(10,2)
  status        BookingStatus @default(PENDING)
  holdId String? @unique
  createdAt     DateTime      @default(now())
  venue         Venue         @relation(fields: [venueId], references: [id])
  user          User          @relation("BookingUser", fields: [userId], references: [id])
  owner         User          @relation("BookingOwner", fields: [ownerId], references: [id])
  hold          Hold?         @relation(fields: [holdId], references: [id])
}

model Wallet {
  id          String        @id @default(uuid())
  userId      String        @unique
  balance     Decimal       @default(0) @db.Decimal(12,2)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  ledgerEntries LedgerEntry[]
  holds       Hold[]
  createdAt   DateTime      @default(now())
}

model LedgerEntry {
  id          String          @id @default(uuid())
  walletId    String
  type        LedgerEntryType
  amount      Decimal         @db.Decimal(12,2)
  description String
  referenceId String?
  createdAt   DateTime        @default(now())
  wallet      Wallet          @relation(fields: [walletId], references: [id], onDelete: Cascade)
}

model Hold {
  id            String      @id @default(uuid())
  walletId      String
  amount        Decimal     @db.Decimal(12,2)
  status        HoldStatus  @default(ACTIVE)
  reason        String
  referenceId   String
  createdAt     DateTime    @default(now())
  wallet        Wallet      @relation(fields: [walletId], references: [id], onDelete: Cascade)
  booking Booking?

  @@index([walletId, status])
}
